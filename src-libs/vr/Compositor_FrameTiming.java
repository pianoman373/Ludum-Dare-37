package vr;

import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import java.util.Arrays;
import java.util.List;

/**
 * This file was autogenerated by
 * <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that
 * <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a
 * few opensource projects.</a>.<br>
 * For help, please visit
 * <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> ,
 * <a href="http://rococoa.dev.java.net/">Rococoa</a>, or
 * <a href="http://jna.dev.java.net/">JNA</a>
 *
 * Provides a single frame's timing information to the app.
 */
public class Compositor_FrameTiming extends Structure {

    /**
     * Set to sizeof( Compositor_FrameTiming )
     */
    public int m_nSize;
    public int m_nFrameIndex;
    /**
     * number of times this frame was presented
     */
    public int m_nNumFramePresents;
    /**
     * number of additional times previous frame was scanned out
     */
    public int m_nNumDroppedFrames;
    public int m_nReprojectionFlags;

    /**
     * Absolute time reference for comparing frames. This aligns with the vsync
     * that running start is relative to.
     */
    public double m_flSystemTimeInSeconds;

    /*
      These times may include work from other processes due to OS scheduling.
      The fewer packets of work these are broken up into, the less likely this
      will happen. GPU work can be broken up by calling Flush. This can
      sometimes be useful to get the GPU started processing that work earlier
      in the frame.
     */
    /**
     * time spent rendering the scene (gpu work submitted between WaitGetPoses
     * and second Submit)
     */
    public float m_flPreSubmitGpuMs;
    /**
     * additional time spent rendering by application (e.g. companion window)
     */
    public float m_flPostSubmitGpuMs;
    /**
     * time between work submitted immediately after present (ideally vsync)
     * until the end of compositor submitted work
     *
     */
    public float m_flTotalRenderGpuMs;
    /**
     * time spend performing distortion correction, rendering chaperone,
     * overlays, etc.
     *
     */
    public float m_flCompositorRenderGpuMs;
    /**
     * time spent on cpu submitting the above work for this frame
     */
    public float m_flCompositorRenderCpuMs;
    /**
     * time spent waiting for running start (application could have used this
     * much more time)
     */
    public float m_flCompositorIdleCpuMs;
    /**
     * Miscellaneous measured intervals.
     */
    // time between calls to WaitGetPoses
    public float m_flClientFrameIntervalMs;
    // time blocked on call to present (usually 0.0, but can go long)
    public float m_flPresentCallCpuMs;
    // time spent spin-waiting for frame index to change (not near-zero indicates wait object failure)
    public float m_flWaitForPresentCpuMs;
    // time spent in IVRCompositor::Submit (not near-zero indicates driver issue)    
    public float m_flSubmitFrameMs;

    /**
     * The following are all relative to this frame's SystemTimeInSeconds
     */
    public float m_flWaitGetPosesCalledMs;
    public float m_flNewPosesReadyMs;
    public float m_flNewFrameReadyMs;   // second call to IVRCompositor::Submit
    public float m_flCompositorUpdateStartMs;
    public float m_flCompositorUpdateEndMs;
    public float m_flCompositorRenderStartMs;
    /**
     * C type : TrackedDevicePose_t
     *
     * pose used by app to render this frame.
     */
    public TrackedDevicePose_t m_HmdPose;


    public Compositor_FrameTiming() {
        super();
    }

    @Override
    protected List<?> getFieldOrder() {
        return Arrays.asList("m_nSize", "m_nFrameIndex", "m_nNumFramePresents", "m_nNumDroppedFrames", "m_nReprojectionFlags", "m_flSystemTimeInSeconds", "m_flPreSubmitGpuMs", "m_flPostSubmitGpuMs", "m_flTotalRenderGpuMs", "m_flCompositorRenderGpuMs", "m_flCompositorRenderCpuMs", "m_flCompositorIdleCpuMs", "m_flClientFrameIntervalMs", "m_flPresentCallCpuMs", "m_flWaitForPresentCpuMs", "m_flSubmitFrameMs", "m_flWaitGetPosesCalledMs", "m_flNewPosesReadyMs", "m_flNewFrameReadyMs", "m_flCompositorUpdateStartMs", "m_flCompositorUpdateEndMs", "m_flCompositorRenderStartMs", "m_HmdPose");
    }

    public Compositor_FrameTiming(Pointer peer) {
        super(peer);
        read();
    }

    public static class ByReference extends Compositor_FrameTiming implements Structure.ByReference {
    };

    public static class ByValue extends Compositor_FrameTiming implements Structure.ByValue {
    };
}
