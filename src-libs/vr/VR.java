package vr;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>JOpenVR</b><br>
 * This file was autogenerated by
 * <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that
 * <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a
 * few opensource projects.</a>.<br>
 * For help, please visit
 * <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> ,
 * <a href="http://rococoa.dev.java.net/">Rococoa</a>, or
 * <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class VR implements Library {

    public static final String JNA_LIBRARY_NAME = "openvr_api";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(JNA_LIBRARY_NAME);

    static {
        Native.register(VR.class, JNA_NATIVE_LIB);
    }

    public static int k_unTrackingStringSize = 32;
    public static int k_unMaxDriverDebugResponseSize = 32768;
    public static int k_unTrackedDeviceIndex_Hmd = 0;
    public static int k_unMaxTrackedDeviceCount = 16;
    public static long k_unTrackedDeviceIndexOther = 4294967294L; //0xFFFFFFFE
    public static long k_unTrackedDeviceIndexInvalid = 4294967295L; // 0xFFFFFFFF
    /**
     * No string property will ever be longer than this length.
     */
    public static int k_unMaxPropertyStringSize = 32768;
    /**
     * the number of axes in the controller state.
     */
    public static int k_unControllerStateAxisCount = 5;
    public static long k_ulOverlayHandleInvalid = 0L;
    static int k_unScreenshotHandleInvalid = 0;
    public static String IVRSystem_Version = "FnTable:IVRSystem_012";
    public static String IVRExtendedDisplay_Version = "FnTable:IVRExtendedDisplay_001";
    public static String IVRTrackedCamera_Version = "FnTable:IVRTrackedCamera_003";
    /**
     * The maximum length of an application key.
     */
    public static int k_unMaxApplicationKeyLength = 128;
    public static String IVRApplications_Version = "FnTable:IVRApplications_006";
    public static String IVRChaperone_Version = "FnTable:IVRChaperone_003";
    public static String IVRChaperoneSetup_Version = "FnTable:IVRChaperoneSetup_005";
    public static String IVRCompositor_Version = "FnTable:IVRCompositor_016";
    public static int k_unVROverlayMaxKeyLength = 128;
    public static int k_unVROverlayMaxNameLength = 128;
    public static int k_unMaxOverlayCount = 64;
    public static String IVROverlay_Version = "FnTable:IVROverlay_013";
    public static String k_pch_Controller_Component_GDC2015 = "gdc2015";
    public static String k_pch_Controller_Component_Base = "base";
    public static String k_pch_Controller_Component_Tip = "tip";
    public static String k_pch_Controller_Component_HandGrip = "handgrip";
    public static String k_pch_Controller_Component_Status = "status";
    public static String IVRRenderModels_Version = "FnTable:IVRRenderModels_005";
    public static int k_unNotificationTextMaxSize = 256;
    public static String IVRNotifications_Version = "FnTable:IVRNotifications_002";
    public static int k_unMaxSettingsKeyLength = 128;
    public static String IVRSettings_Version = "FnTable:IVRSettings_001";
    public static String k_pch_SteamVR_Section = "steamvr";
    public static String k_pch_SteamVR_RequireHmd_String = "requireHmd";
    public static String k_pch_SteamVR_ForcedDriverKey_String = "forcedDriver";
    public static String k_pch_SteamVR_ForcedHmdKey_String = "forcedHmd";
    public static String k_pch_SteamVR_DisplayDebug_Bool = "displayDebug";
    public static String k_pch_SteamVR_DebugProcessPipe_String = "debugProcessPipe";
    public static String k_pch_SteamVR_EnableDistortion_Bool = "enableDistortion";
    public static String k_pch_SteamVR_DisplayDebugX_Int32 = "displayDebugX";
    public static String k_pch_SteamVR_DisplayDebugY_Int32 = "displayDebugY";
    public static String k_pch_SteamVR_SendSystemButtonToAllApps_Bool = "sendSystemButtonToAllApps";
    public static String k_pch_SteamVR_LogLevel_Int32 = "loglevel";
    public static String k_pch_SteamVR_IPD_Float = "ipd";
    public static String k_pch_SteamVR_Background_String = "background";
    public static String k_pch_SteamVR_BackgroundCameraHeight_Float = "backgroundCameraHeight";
    public static String k_pch_SteamVR_BackgroundDomeRadius_Float = "backgroundDomeRadius";
    public static String k_pch_SteamVR_Environment_String = "environment";
    public static String k_pch_SteamVR_GridColor_String = "gridColor";
    public static String k_pch_SteamVR_PlayAreaColor_String = "playAreaColor";
    public static String k_pch_SteamVR_ShowStage_Bool = "showStage";
    public static String k_pch_SteamVR_ActivateMultipleDrivers_Bool = "activateMultipleDrivers";
    public static String k_pch_SteamVR_PowerOffOnExit_Bool = "powerOffOnExit";
    public static String k_pch_SteamVR_StandbyAppRunningTimeout_Float = "standbyAppRunningTimeout";
    public static String k_pch_SteamVR_StandbyNoAppTimeout_Float = "standbyNoAppTimeout";
    public static String k_pch_SteamVR_DirectMode_Bool = "directMode";
    public static String k_pch_SteamVR_DirectModeEdidVid_Int32 = "directModeEdidVid";
    public static String k_pch_SteamVR_DirectModeEdidPid_Int32 = "directModeEdidPid";
    public static String k_pch_SteamVR_UsingSpeakers_Bool = "usingSpeakers";
    public static String k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float = "speakersForwardYawOffsetDegrees";
    public static String k_pch_SteamVR_BaseStationPowerManagement_Bool = "basestationPowerManagement";
    public static String k_pch_SteamVR_NeverKillProcesses_Bool = "neverKillProcesses";
    public static String k_pch_SteamVR_RenderTargetMultiplier_Float = "renderTargetMultiplier";
    public static String k_pch_SteamVR_AllowReprojection_Bool = "allowReprojection";
    public static String k_pch_SteamVR_ForceReprojection_Bool = "forceReprojection";
    public static String k_pch_SteamVR_ForceFadeOnBadTracking_Bool = "forceFadeOnBadTracking";
    public static String k_pch_SteamVR_DefaultMirrorView_Int32 = "defaultMirrorView";
    public static String k_pch_SteamVR_ShowMirrorView_Bool = "showMirrorView";
    public static String k_pch_SteamVR_StartMonitorFromAppLaunch = "startMonitorFromAppLaunch";
    public static String k_pch_SteamVR_AutoLaunchSteamVROnButtonPress = "autoLaunchSteamVROnButtonPress";
    public static String k_pch_SteamVR_UseGenericGraphcisDevice_Bool = "useGenericGraphicsDevice";
    public static String k_pch_Lighthouse_Section = "driver_lighthouse";
    public static String k_pch_Lighthouse_DisableIMU_Bool = "disableimu";
    public static String k_pch_Lighthouse_UseDisambiguation_String = "usedisambiguation";
    public static String k_pch_Lighthouse_DisambiguationDebug_Int32 = "disambiguationdebug";
    public static String k_pch_Lighthouse_PrimaryBasestation_Int32 = "primarybasestation";
    public static String k_pch_Lighthouse_LighthouseName_String = "lighthousename";
    public static String k_pch_Lighthouse_MaxIncidenceAngleDegrees_Float = "maxincidenceangledegrees";
    public static String k_pch_Lighthouse_UseLighthouseDirect_Bool = "uselighthousedirect";
    public static String k_pch_Lighthouse_DBHistory_Bool = "dbhistory";
    public static String k_pch_Null_Section = "driver_null";
    public static String k_pch_Null_EnableNullDriver_Bool = "enable";
    public static String k_pch_Null_SerialNumber_String = "serialNumber";
    public static String k_pch_Null_ModelNumber_String = "modelNumber";
    public static String k_pch_Null_WindowX_Int32 = "windowX";
    public static String k_pch_Null_WindowY_Int32 = "windowY";
    public static String k_pch_Null_WindowWidth_Int32 = "windowWidth";
    public static String k_pch_Null_WindowHeight_Int32 = "windowHeight";
    public static String k_pch_Null_RenderWidth_Int32 = "renderWidth";
    public static String k_pch_Null_RenderHeight_Int32 = "renderHeight";
    public static String k_pch_Null_SecondsFromVsyncToPhotons_Float = "secondsFromVsyncToPhotons";
    public static String k_pch_Null_DisplayFrequency_Float = "displayFrequency";
    public static String k_pch_UserInterface_Section = "userinterface";
    public static String k_pch_UserInterface_StatusAlwaysOnTop_Bool = "StatusAlwaysOnTop";
    public static String k_pch_UserInterface_Screenshots_Bool = "screenshots";
    public static String k_pch_UserInterface_ScreenshotType_Int = "screenshotType";
    public static String k_pch_Notifications_Section = "notifications";
    public static String k_pch_Notifications_DoNotDisturb_Bool = "DoNotDisturb";
    public static String k_pch_Keyboard_Section = "keyboard";
    public static String k_pch_Keyboard_TutorialCompletions = "TutorialCompletions";
    public static String k_pch_Keyboard_ScaleX = "ScaleX";
    public static String k_pch_Keyboard_ScaleY = "ScaleY";
    public static String k_pch_Keyboard_OffsetLeftX = "OffsetLeftX";
    public static String k_pch_Keyboard_OffsetRightX = "OffsetRightX";
    public static String k_pch_Keyboard_OffsetY = "OffsetY";
    public static String k_pch_Keyboard_Smoothing = "Smoothing";
    public static String k_pch_Perf_Section = "perfcheck";
    public static String k_pch_Perf_HeuristicActive_Bool = "heuristicActive";
    public static String k_pch_Perf_NotifyInHMD_Bool = "warnInHMD";
    public static String k_pch_Perf_NotifyOnlyOnce_Bool = "warnOnlyOnce";
    public static String k_pch_Perf_AllowTimingStore_Bool = "allowTimingStore";
    public static String k_pch_Perf_SaveTimingsOnExit_Bool = "saveTimingsOnExit";
    public static String k_pch_Perf_TestData_Float = "perfTestData";
    public static String k_pch_CollisionBounds_Section = "collisionBounds";
    public static String k_pch_CollisionBounds_Style_Int32 = "CollisionBoundsStyle";
    public static String k_pch_CollisionBounds_GroundPerimeterOn_Bool = "CollisionBoundsGroundPerimeterOn";
    public static String k_pch_CollisionBounds_CenterMarkerOn_Bool = "CollisionBoundsCenterMarkerOn";
    public static String k_pch_CollisionBounds_PlaySpaceOn_Bool = "CollisionBoundsPlaySpaceOn";
    public static String k_pch_CollisionBounds_FadeDistance_Float = "CollisionBoundsFadeDistance";
    public static String k_pch_CollisionBounds_ColorGammaR_Int32 = "CollisionBoundsColorGammaR";
    public static String k_pch_CollisionBounds_ColorGammaG_Int32 = "CollisionBoundsColorGammaG";
    public static String k_pch_CollisionBounds_ColorGammaB_Int32 = "CollisionBoundsColorGammaB";
    public static String k_pch_CollisionBounds_ColorGammaA_Int32 = "CollisionBoundsColorGammaA";
    public static String k_pch_Camera_Section = "camera";
    public static String k_pch_Camera_EnableCamera_Bool = "enableCamera";
    public static String k_pch_Camera_EnableCameraInDashboard_Bool = "enableCameraInDashboard";
    public static String k_pch_Camera_EnableCameraForCollisionBounds_Bool = "enableCameraForCollisionBounds";
    public static String k_pch_Camera_EnableCameraForRoomView_Bool = "enableCameraForRoomView";
    public static String k_pch_Camera_BoundsColorGammaR_Int32 = "cameraBoundsColorGammaR";
    public static String k_pch_Camera_BoundsColorGammaG_Int32 = "cameraBoundsColorGammaG";
    public static String k_pch_Camera_BoundsColorGammaB_Int32 = "cameraBoundsColorGammaB";
    public static String k_pch_Camera_BoundsColorGammaA_Int32 = "cameraBoundsColorGammaA";
    public static String k_pch_audio_Section = "audio";
    public static String k_pch_audio_OnPlaybackDevice_String = "onPlaybackDevice";
    public static String k_pch_audio_OnRecordDevice_String = "onRecordDevice";
    public static String k_pch_audio_OnPlaybackMirrorDevice_String = "onPlaybackMirrorDevice";
    public static String k_pch_audio_OffPlaybackDevice_String = "offPlaybackDevice";
    public static String k_pch_audio_OffRecordDevice_String = "offRecordDevice";
    public static String k_pch_audio_VIVEHDMIGain = "viveHDMIGain";
    public static String k_pch_modelskin_Section = "modelskins";
    public static String IVRScreenshots_Version = "IVRScreenshots_001";
    public static String IVRResources_Version = "IVRResources_001";

    // OpenVR Enums
    public static class EVREye {

        public static final int EYE_Left = 0;
        public static final int Eye_Right = 1;
        // only for jovr
        public static final int Max = 2;
    };

    public static class EGraphicsAPIConvention {

        public static final int API_DirectX = 0; // Normalized Z goes from 0 at the viewer to 1 at the far clip plane
        public static final int API_OpenGL = 1; // Normalized Z goes from 1 at the viewer to -1 at the far clip plane
    };

    public static class EColorSpace {

        /**
         * Assumes 'gamma' for 8-bit per component formats, otherwise 'linear'.
         * This mirrors the DXGI formats which have _SRGB variants.
         */
        public static final int ColorSpace_Auto = 0;
        //Texture data can be displayed directly on the display without any conversion (a.k.a. display native format).
        public static final int ColorSpace_Gamma = 1;
        // Same as gamma but has been converted to a linear representation using DXGI's sRGB conversion algorithm.
        public static final int ColorSpace_Linear = 2;
    };

    public static class ETrackingResult {

        public static final int TrackingResult_Uninitialized = 1;
        public static final int TrackingResult_Calibrating_InProgress = 100;
        public static final int TrackingResult_Calibrating_OutOfRange = 101;
        public static final int TrackingResult_Running_OK = 200;
        public static final int TrackingResult_Running_OutOfRange = 201;
    };

    /**
     * Describes what kind of object is being tracked at a given ID.
     */
    public static class ETrackedDeviceClass {

        public static final int TrackedDeviceClass_Invalid = 0; // the ID was not valid.
        public static final int TrackedDeviceClass_HMD = 1; // Head-Mounted Displays
        public static final int TrackedDeviceClass_Controller = 2; // Tracked controllers
        public static final int TrackedDeviceClass_TrackingReference = 4;// Camera and base stations that serve as tracking reference points
        public static final int TrackedDeviceClass_Other = 1000;
    };

    /**
     * Describes what specific role associated with a tracked device
     */
    public static class ETrackedControllerRole {

        public static final int TrackedControllerRole_Invalid = 0; // Invalid value for controller type
        public static final int TrackedControllerRole_LeftHand = 1; // Tracked device associated with the left hand
        public static final int TrackedControllerRole_RightHand = 2; // Tracked device associated with the right hand
    };

    /**
     * Identifies which style of tracking origin the application wants to use
     * for the poses it is requesting.
     */
    public static class ETrackingUniverseOrigin {

        public static final int TrackingUniverseSeated = 0;// Poses are provided relative to the seated zero pose
        public static final int TrackingUniverseStanding = 1;// Poses are provided relative to the safe bounds configured by the user
        public static final int TrackingUniverseRawAndUncalibrated = 2;// Poses are provided in the coordinate system defined by the driver. You probably don't want this one.
    };

    /**
     * Each entry in this enum represents a property that can be retrieved about
     * a tracked device. Many fields are only valid for one ETrackedDeviceClass.
     */
    public static class ETrackedDeviceProperty {

        // general properties that apply to all device classes
        public static final int Prop_TrackingSystemName_String = 1000;
        public static final int Prop_ModelNumber_String = 1001;
        public static final int Prop_SerialNumber_String = 1002;
        public static final int Prop_RenderModelName_String = 1003;
        public static final int Prop_WillDriftInYaw_Bool = 1004;
        public static final int Prop_ManufacturerName_String = 1005;
        public static final int Prop_TrackingFirmwareVersion_String = 1006;
        public static final int Prop_HardwareRevision_String = 1007;
        public static final int Prop_AllWirelessDongleDescriptions_String = 1008;
        public static final int Prop_ConnectedWirelessDongle_String = 1009;
        public static final int Prop_DeviceIsWireless_Bool = 1010;
        public static final int Prop_DeviceIsCharging_Bool = 1011;
        public static final int Prop_DeviceBatteryPercentage_Float = 1012;  // 0 is empty, 1 is full
        public static final int Prop_StatusDisplayTransform_Matrix34 = 1013;
        public static final int Prop_Firmware_UpdateAvailable_Bool = 1014;
        public static final int Prop_Firmware_ManualUpdate_Bool = 1015;
        public static final int Prop_Firmware_ManualUpdateURL_String = 1016;
        public static final int Prop_HardwareRevision_Uint64 = 1017;
        public static final int Prop_FirmwareVersion_Uint64 = 1018;
        public static final int Prop_FPGAVersion_Uint64 = 1019;
        public static final int Prop_VRCVersion_Uint64 = 1020;
        public static final int Prop_RadioVersion_Uint64 = 1021;
        public static final int Prop_DongleVersion_Uint64 = 1022;
        public static final int Prop_BlockServerShutdown_Bool = 1023;
        public static final int Prop_CanUnifyCoordinateSystemWithHmd_Bool = 1024;
        public static final int Prop_ContainsProximitySensor_Bool = 1025;
        public static final int Prop_DeviceProvidesBatteryStatus_Bool = 1026;
        public static final int Prop_DeviceCanPowerOff_Bool = 1027;
        public static final int Prop_Firmware_ProgrammingTarget_String = 1028;
        public static final int Prop_DeviceClass_Int32 = 1029;
        public static final int Prop_HasCamera_Bool = 1030;
        public static final int Prop_DriverVersion_String = 1031;
        public static final int Prop_Firmware_ForceUpdateRequired_Bool = 1032;

        // Properties that are unique to TrackedDeviceClass_HMD
        public static final int Prop_ReportsTimeSinceVSync_Bool = 2000;
        public static final int Prop_SecondsFromVsyncToPhotons_Float = 2001;
        public static final int Prop_DisplayFrequency_Float = 2002;
        public static final int Prop_UserIpdMeters_Float = 2003;
        public static final int Prop_CurrentUniverseId_Uint64 = 2004;
        public static final int Prop_PreviousUniverseId_Uint64 = 2005;
        public static final int Prop_DisplayFirmwareVersion_Uint64 = 2006;
        public static final int Prop_IsOnDesktop_Bool = 2007;
        public static final int Prop_DisplayMCType_Int32 = 2008;
        public static final int Prop_DisplayMCOffset_Float = 2009;
        public static final int Prop_DisplayMCScale_Float = 2010;
        public static final int Prop_EdidVendorID_Int32 = 2011;
        public static final int Prop_DisplayMCImageLeft_String = 2012;
        public static final int Prop_DisplayMCImageRight_String = 2013;
        public static final int Prop_DisplayGCBlackClamp_Float = 2014;
        public static final int Prop_EdidProductID_Int32 = 2015;
        public static final int Prop_CameraToHeadTransform_Matrix34 = 2016;
        public static final int Prop_DisplayGCType_Int32 = 2017;
        public static final int Prop_DisplayGCOffset_Float = 2018;
        public static final int Prop_DisplayGCScale_Float = 2019;
        public static final int Prop_DisplayGCPrescale_Float = 2020;
        public static final int Prop_DisplayGCImage_String = 2021;
        public static final int Prop_LensCenterLeftU_Float = 2022;
        public static final int Prop_LensCenterLeftV_Float = 2023;
        public static final int Prop_LensCenterRightU_Float = 2024;
        public static final int Prop_LensCenterRightV_Float = 2025;
        public static final int Prop_UserHeadToEyeDepthMeters_Float = 2026;
        public static final int Prop_CameraFirmwareVersion_Uint64 = 2027;
        public static final int Prop_CameraFirmwareDescription_String = 2028;
        public static final int Prop_DisplayFPGAVersion_Uint64 = 2029;
        public static final int Prop_DisplayBootloaderVersion_Uint64 = 2030;
        public static final int Prop_DisplayHardwareVersion_Uint64 = 2031;
        public static final int Prop_AudioFirmwareVersion_Uint64 = 2032;
        public static final int Prop_CameraCompatibilityMode_Int32 = 2033;
        public static final int Prop_ScreenshotHorizontalFieldOfViewDegrees_Float = 2034;
        public static final int Prop_ScreenshotVerticalFieldOfViewDegrees_Float = 2035;
        public static final int Prop_DisplaySuppressed_Bool = 2036;

        // Properties that are unique to TrackedDeviceClass_Controller
        public static final int Prop_AttachedDeviceId_String = 3000;
        public static final int Prop_SupportedButtons_Uint64 = 3001;
        public static final int Prop_Axis0Type_Int32 = 3002;    // Return value is of type EVRControllerAxisType
        public static final int Prop_Axis1Type_Int32 = 3003;    // Return value is of type EVRControllerAxisType
        public static final int Prop_Axis2Type_Int32 = 3004;    // Return value is of type EVRControllerAxisType
        public static final int Prop_Axis3Type_Int32 = 3005;    // Return value is of type EVRControllerAxisType
        public static final int Prop_Axis4Type_Int32 = 3006;    // Return value is of type EVRControllerAxisType
        public static final int Prop_ControllerRoleHint_Int32 = 3007;// Return value is of type ETrackedControllerRole

        // Properties that are unique to TrackedDeviceClass_TrackingReference
        public static final int Prop_FieldOfViewLeftDegrees_Float = 4000;
        public static final int Prop_FieldOfViewRightDegrees_Float = 4001;
        public static final int Prop_FieldOfViewTopDegrees_Float = 4002;
        public static final int Prop_FieldOfViewBottomDegrees_Float = 4003;
        public static final int Prop_TrackingRangeMinimumMeters_Float = 4004;
        public static final int Prop_TrackingRangeMaximumMeters_Float = 4005;
        public static final int Prop_ModeLabel_String = 4006;

        // Vendors are free to expose private debug data in this reserved region
        public static final int Prop_VendorSpecific_Reserved_Start = 10000;
        public static final int Prop_VendorSpecific_Reserved_End = 10999;
    };

    /**
     * Used to return errors that occur when reading properties.
     */
    public static class ETrackedPropertyError {

        public static final int TrackedProp_Success = 0;
        public static final int TrackedProp_WrongDataType = 1;
        public static final int TrackedProp_WrongDeviceClass = 2;
        public static final int TrackedProp_BufferTooSmall = 3;
        public static final int TrackedProp_UnknownProperty = 4;
        public static final int TrackedProp_InvalidDevice = 5;
        public static final int TrackedProp_CouldNotContactServer = 6;
        public static final int TrackedProp_ValueNotProvidedByDevice = 7;
        public static final int TrackedProp_StringExceedsMaximumLength = 8;
        // The property value isn't known yet, but is expected soon. Call again later.
        public static final int TrackedProp_NotYetAvailable = 9;
    };

    /**
     * Allows the application to control how scene textures are used by the
     * compositor when calling Submit.
     */
    public static class EVRSubmitFlags {

        /**
         * Simple render path. App submits rendered left and right eye images
         * with no lens distortion correction applied.
         */
        public static final int Submit_Default = 0;
        /**
         * App submits final left and right eye images with lens distortion
         * already applied (lens distortion makes the images appear barrel
         * distorted with chromatic aberration correction applied). The app
         * would have used the data returned by
         * vr::IVRSystem::ComputeDistortion() to apply the correct distortion to
         * the rendered images before calling Submit().
         */
        public static final int Submit_LensDistortionAlreadyApplied = 1;
        /**
         * If the texture pointer passed in is actually a renderbuffer (e.g. for
         * MSAA in OpenGL) then set this flag.
         */
        public static final int Submit_GlRenderBuffer = 2;
    };

    /**
     * Status of the overall system or tracked objects
     */
    public static class EVRState {

        public static final int VRState_Undefined = -1;
        public static final int VRState_Off = 0;
        public static final int VRState_Searching = 1;
        public static final int VRState_Searching_Alert = 2;
        public static final int VRState_Ready = 3;
        public static final int VRState_Ready_Alert = 4;
        public static final int VRState_NotReady = 5;
        public static final int VRState_Standby = 6;
        public static final int VRState_Ready_Alert_Low = 7;
    };

    /**
     * The types of events that could be posted (and what the parameters mean
     * for each event type)
     */
    public static class EVREventType {

        public static final int VREvent_None = 0;

        public static final int VREvent_TrackedDeviceActivated = 100;
        public static final int VREvent_TrackedDeviceDeactivated = 101;
        public static final int VREvent_TrackedDeviceUpdated = 102;
        public static final int VREvent_TrackedDeviceUserInteractionStarted = 103;
        public static final int VREvent_TrackedDeviceUserInteractionEnded = 104;
        public static final int VREvent_IpdChanged = 105;
        public static final int VREvent_EnterStandbyMode = 106;
        public static final int VREvent_LeaveStandbyMode = 107;
        public static final int VREvent_TrackedDeviceRoleChanged = 108;
        public static final int VREvent_WatchdogWakeUpRequested = 109;

        public static final int VREvent_ButtonPress = 200;      // data is controller
        public static final int VREvent_ButtonUnpress = 201;    // data is controller
        public static final int VREvent_ButtonTouch = 202;      // data is controller
        public static final int VREvent_ButtonUntouch = 203;    // data is controller

        public static final int VREvent_MouseMove = 300;        // data is mouse
        public static final int VREvent_MouseButtonDown = 301;  // data is mouse
        public static final int VREvent_MouseButtonUp = 302;    // data is mouse
        public static final int VREvent_FocusEnter = 303;       // data is overlay
        public static final int VREvent_FocusLeave = 304;       // data is overlay
        public static final int VREvent_Scroll = 305;           // data is mouse
        public static final int VREvent_TouchPadMove = 306;     // data is mouse
        public static final int VREvent_OverlayFocusChanged = 307;     // data is overlay, global event

        public static final int VREvent_InputFocusCaptured = 400;       // data is process DEPRECATED
        public static final int VREvent_InputFocusReleased = 401;       // data is process DEPRECATED
        public static final int VREvent_SceneFocusLost = 402;           // data is process
        public static final int VREvent_SceneFocusGained = 403;         // data is process
        // The App actually drawing the scene changed (usually to or from the compositor)
        public static final int VREvent_SceneApplicationChanged = 404;  // data is process
        // New app got access to draw the scene
        public static final int VREvent_SceneFocusChanged = 405;        // data is process
        public static final int VREvent_InputFocusChanged = 406;        // data is process
        public static final int VVREvent_SceneApplicationSecondaryRenderingStarted = 407;        // data is process

        // Sent to the scene application to request hiding render models temporarily
        public static final int VREvent_HideRenderModels = 410;
        // Sent to the scene application to request restoring render model visibility
        public static final int VREvent_ShowRenderModels = 411;

        public static final int VREvent_OverlayShown = 500;
        public static final int VREvent_OverlayHidden = 501;
        public static final int VREvent_DashboardActivated = 502;
        public static final int VREvent_DashboardDeactivated = 503;
        public static final int VREvent_DashboardThumbSelected = 504;   // Sent to the overlay manager - data is overlay
        public static final int VREvent_DashboardRequested = 505;       // Sent to the overlay manager - data is overlay
        public static final int VREvent_ResetDashboard = 506;           // Send to the overlay manager
        // data is the notification ID
        public static final int VREvent_RenderToast = 507;              // Send to the dashboard to render a toast
        // Sent to overlays when a SetOverlayRaw or SetOverlayFromFile call finishes loading
        public static final int VREvent_ImageLoaded = 508;
        // Sent to keyboard renderer in the dashboard to invoke it
        public static final int VREvent_ShowKeyboard = 509;
        // Sent to keyboard renderer in the dashboard to hide it
        public static final int VREvent_HideKeyboard = 510;
        // Sent to an overlay when IVROverlay::SetFocusOverlay is called on it
        public static final int VREvent_OverlayGamepadFocusGained = 511;
        // Send to an overlay when it previously had focus and IVROverlay::SetFocusOverlay is called on something else
        public static final int VREvent_OverlayGamepadFocusLost = 512;
        public static final int VREvent_OverlaySharedTextureChanged = 513;
        public static final int VREvent_DashboardGuideButtonDown = 514;
        public static final int VREvent_DashboardGuideButtonUp = 515;
        public static final int VREvent_ScreenshotTriggered = 516;
        public static final int VREvent_ImageFailed = 517;
        public static final int VREvent_RequestScreenshot = 520;
        public static final int VREvent_ScreenshotTaken = 521;
        public static final int VREvent_ScreenshotFailed = 522;
        public static final int VREvent_SubmitScreenshotToDashboard = 523;
        public static final int VREvent_ScreenshotProgressToDashboard = 524;

        public static final int VREvent_Notification_Shown = 600;
        public static final int VREvent_Notification_Hidden = 601;
        public static final int VREvent_Notification_BeginInteraction = 602;
        public static final int VREvent_Notification_Destroyed = 603;

        public static final int VREvent_Quit = 700;                     // data is process
        public static final int VREvent_ProcessQuit = 701;              // data is process
        public static final int VREvent_QuitAborted_UserPrompt = 702;   // data is process
        public static final int VREvent_QuitAcknowledged = 703;         // data is process
        public static final int VREvent_DriverRequestedQuit = 704;      // The driver has requested that SteamVR shut down

        public static final int VREvent_ChaperoneDataHasChanged = 800;
        public static final int VREvent_ChaperoneUniverseHasChanged = 801;
        public static final int VREvent_ChaperoneTempDataHasChanged = 802;
        public static final int VREvent_ChaperoneSettingsHaveChanged = 803;
        public static final int VREvent_SeatedZeroPoseReset = 804;

        public static final int VREvent_AudioSettingsHaveChanged = 820;

        public static final int VREvent_BackgroundSettingHasChanged = 850;
        public static final int VREvent_CameraSettingsHaveChanged = 851;
        public static final int VREvent_ReprojectionSettingHasChanged = 852;
        public static final int VREvent_ModelSkinSettingsHaveChanged = 853;
        public static final int VREvent_EnvironmentSettingsHaveChanged = 854;

        public static final int VREvent_StatusUpdate = 900;

        public static final int VREvent_MCImageUpdated = 1000;

        public static final int VREvent_FirmwareUpdateStarted = 1100;
        public static final int VREvent_FirmwareUpdateFinished = 1101;

        public static final int VREvent_KeyboardClosed = 1200;
        public static final int VREvent_KeyboardCharInput = 1201;
        public static final int VREvent_KeyboardDone = 1202;        // Sent when DONE button clicked on keyboard

        public static final int VREvent_ApplicationTransitionStarted = 1300;
        public static final int VREvent_ApplicationTransitionAborted = 1301;
        public static final int VREvent_ApplicationTransitionNewAppStarted = 1302;
        public static final int VREvent_ApplicationListUpdated = 1303;
        public static final int VREvent_ApplicationMimeTypeLoad = 1304;

        public static final int VREvent_Compositor_MirrorWindowShown = 1400;
        public static final int VREvent_Compositor_MirrorWindowHidden = 1401;
        public static final int VREvent_Compositor_ChaperoneBoundsShown = 1410;
        public static final int VREvent_Compositor_ChaperoneBoundsHidden = 1411;

        public static final int VREvent_TrackedCamera_StartVideoStream = 1500;
        public static final int VREvent_TrackedCamera_StopVideoStream = 1501;
        public static final int VREvent_TrackedCamera_PauseVideoStream = 1502;
        public static final int VREvent_TrackedCamera_ResumeVideoStream = 1503;

        public static final int VREvent_PerformanceTest_EnableCapture = 1600;
        public static final int VREvent_PerformanceTest_DisableCapture = 1601;
        public static final int VREvent_PerformanceTest_FidelityLevel = 1602;

        // Vendors are free to expose private events in this reserved region
        public static final int VREvent_VendorSpecific_Reserved_Start = 10000;
        public static final int VREvent_VendorSpecific_Reserved_End = 19999;
    };

    /**
     * Level of Hmd activity.
     */
    public static class EDeviceActivityLevel {

        public static final int k_EDeviceActivityLevel_Unknown = -1;
        public static final int k_EDeviceActivityLevel_Idle = 0;
        public static final int k_EDeviceActivityLevel_UserInteraction = 1;
        public static final int k_EDeviceActivityLevel_UserInteraction_Timeout = 2;
        public static final int k_EDeviceActivityLevel_Standby = 3;
    };

    /**
     * VR controller button and axis IDs
     */
    public static class EVRButtonId {

        public static final int k_EButton_System = 0;
        public static final int k_EButton_ApplicationMenu = 1;
        public static final int k_EButton_Grip = 2;
        public static final int k_EButton_DPad_Left = 3;
        public static final int k_EButton_DPad_Up = 4;
        public static final int k_EButton_DPad_Right = 5;
        public static final int k_EButton_DPad_Down = 6;
        public static final int k_EButton_A = 7;

        public static final int k_EButton_Axis0 = 32;
        public static final int k_EButton_Axis1 = 33;
        public static final int k_EButton_Axis2 = 34;
        public static final int k_EButton_Axis3 = 35;
        public static final int k_EButton_Axis4 = 36;

        // aliases for well known controllers
        public static final int k_EButton_SteamVR_Touchpad = k_EButton_Axis0;
        public static final int k_EButton_SteamVR_Trigger = k_EButton_Axis1;

        public static final int k_EButton_Dashboard_Back = k_EButton_Grip;

        public static final int k_EButton_Max = 64;
    };

    /**
     * used for simulated mouse events in overlay space
     */
    public static class EVRMouseButton {

        public static final int VRMouseButton_Left = 1;
        public static final int VRMouseButton_Right = 2;
        public static final int VRMouseButton_Middle = 4;
    };

    /**
     * Identifies what kind of axis is on the controller at index n. Read this
     * type with pVRSystem->Get( nControllerDeviceIndex, Prop_Axis0Type_Int32 +
     * n );
     */
    public static class EVRControllerAxisType {

        public static final int k_eControllerAxis_None = 0;
        public static final int k_eControllerAxis_TrackPad = 1;
        public static final int k_eControllerAxis_Joystick = 2;
        public static final int k_eControllerAxis_Trigger = 3;  // Analog trigger data is in the X axis
    };

    /**
     * determines how to provide output to the application of various event
     * processing functions.
     */
    public static class EVRControllerEventOutputType {

        public static final int ControllerEventOutput_OSEvents = 0;
        public static final int ControllerEventOutput_VREvents = 1;
    };

    /**
     * Collision Bounds Style
     */
    public static class ECollisionBoundsStyle {

        public static final int COLLISION_BOUNDS_STYLE_BEGINNER = 0;
        public static final int COLLISION_BOUNDS_STYLE_INTERMEDIATE = 1;
        public static final int COLLISION_BOUNDS_STYLE_SQUARES = 2;
        public static final int COLLISION_BOUNDS_STYLE_ADVANCED = 3;
        public static final int COLLISION_BOUNDS_STYLE_NONE = 4;
        public static final int COLLISION_BOUNDS_STYLE_COUNT = 5;
    };

    /**
     * Errors that can occur around VR overlays
     */
    public static class EVROverlayError {

        public static final int VROverlayError_None = 0;

        public static final int VROverlayError_UnknownOverlay = 10;
        public static final int VROverlayError_InvalidHandle = 11;
        public static final int VROverlayError_PermissionDenied = 12;
        // No more overlays could be created because the maximum number already exist
        public static final int VROverlayError_OverlayLimitExceeded = 13;
        public static final int VROverlayError_WrongVisibilityType = 14;
        public static final int VROverlayError_KeyTooLong = 15;
        public static final int VROverlayError_NameTooLong = 16;
        public static final int VROverlayError_KeyInUse = 17;
        public static final int VROverlayError_WrongTransformType = 18;
        public static final int VROverlayError_InvalidTrackedDevice = 19;
        public static final int VROverlayError_InvalidParameter = 20;
        public static final int VROverlayError_ThumbnailCantBeDestroyed = 21;
        public static final int VROverlayError_ArrayTooSmall = 22;
        public static final int VROverlayError_RequestFailed = 23;
        public static final int VROverlayError_InvalidTexture = 24;
        public static final int VROverlayError_UnableToLoadFile = 25;
        public static final int VROVerlayError_KeyboardAlreadyInUse = 26;
        public static final int VROverlayError_NoNeighbor = 27;
    };

    /**
     * enum values to pass in to VR_Init to identify whether the application
     * will draw a 3D scene.
     */
    public static class EVRApplicationType {

        // Some other kind of application that isn't covered by the other entries
        public static final int VRApplication_Other = 0;
        // Application will submit 3D frames 
        public static final int VRApplication_Scene = 1;
        // Application only interacts with overlays
        public static final int VRApplication_Overlay = 2;
        /**
         * Application should not start SteamVR if it's not already running, and
         * should not keep it running if everything else quits.
         */
        public static final int VRApplication_Background = 3;
        /**
         * Init should not try to load any drivers. The application needs access
         * to utility classs (like IVRSettings and IVRApplications) but not
         * hardware.
         */
        public static final int VRApplication_Utility = 4;
        // Reserved for vrmonitor
        public static final int VRApplication_VRMonitor = 5;
        public static final int VRApplication_SteamWatchdog = 6;
        public static final int VRApplication_Max = 7;
    };

    /**
     * error codes for firmware
     */
    public static class EVRFirmwareError {

        public static final int VRFirmwareError_None = 0;
        public static final int VRFirmwareError_Success = 1;
        public static final int VRFirmwareError_Fail = 2;
    };

    /**
     * error codes for notifications
     */
    public static class EVRNotificationError {

        public static final int VRNotificationError_OK = 0;
        public static final int VRNotificationError_InvalidNotificationId = 100;
        public static final int VRNotificationError_NotificationQueueFull = 101;
        public static final int VRNotificationError_InvalidOverlayHandle = 102;
        public static final int VRNotificationError_SystemWithUserValueAlreadyExists = 103;
    };

    // Please add adequate error description to https://developer.valvesoftware.com/w/index.php?title=Category:SteamVRHelp
    public static class EVRInitError {

        public static final int VRInitError_None = 0;
        public static final int VRInitError_Unknown = 1;

        public static final int VRInitError_Init_InstallationNotFound = 100;
        public static final int VRInitError_Init_InstallationCorrupt = 101;
        public static final int VRInitError_Init_VRClientDLLNotFound = 102;
        public static final int VRInitError_Init_FileNotFound = 103;
        public static final int VRInitError_Init_FactoryNotFound = 104;
        public static final int VRInitError_Init_InterfaceNotFound = 105;
        public static final int VRInitError_Init_InvalidInterface = 106;
        public static final int VRInitError_Init_UserConfigDirectoryInvalid = 107;
        public static final int VRInitError_Init_HmdNotFound = 108;
        public static final int VRInitError_Init_NotInitialized = 109;
        public static final int VRInitError_Init_PathRegistryNotFound = 110;
        public static final int VRInitError_Init_NoConfigPath = 111;
        public static final int VRInitError_Init_NoLogPath = 112;
        public static final int VRInitError_Init_PathRegistryNotWritable = 113;
        public static final int VRInitError_Init_AppInfoInitFailed = 114;
        // Used internally to cause retries to vrserver
        public static final int VRInitError_Init_Retry = 115;
        // The calling application should silently exit. The user canceled app startup
        public static final int VRInitError_Init_InitCanceledByUser = 116;
        public static final int VRInitError_Init_AnotherAppLaunching = 117;
        public static final int VRInitError_Init_SettingsInitFailed = 118;
        public static final int VRInitError_Init_ShuttingDown = 119;
        public static final int VRInitError_Init_TooManyObjects = 120;
        public static final int VRInitError_Init_NoServerForBackgroundApp = 121;
        public static final int VRInitError_Init_NotSupportedWithCompositor = 122;
        public static final int VRInitError_Init_NotAvailableToUtilityApps = 123;
        public static final int VRInitError_Init_Internal = 124;
        public static final int VRInitError_Init_HmdDriverIdIsNone = 125;
        public static final int VRInitError_Init_HmdNotFoundPresenceFailed = 126;
        public static final int VRInitError_Init_VRMonitorNotFound = 127;
        public static final int VRInitError_Init_VRMonitorStartupFailed = 128;
        public static final int VRInitError_Init_LowPowerWatchdogNotSupported = 129;
        public static final int VRInitError_Init_InvalidApplicationType = 130;
        public static final int VRInitError_Init_NotAvailableToWatchdogApps = 131;
        public static final int VRInitError_Init_WatchdogDisabledInSettings = 132;

        public static final int VRInitError_Driver_Failed = 200;
        public static final int VRInitError_Driver_Unknown = 201;
        public static final int VRInitError_Driver_HmdUnknown = 202;
        public static final int VRInitError_Driver_NotLoaded = 203;
        public static final int VRInitError_Driver_RuntimeOutOfDate = 204;
        public static final int VRInitError_Driver_HmdInUse = 205;
        public static final int VRInitError_Driver_NotCalibrated = 206;
        public static final int VRInitError_Driver_CalibrationInvalid = 207;
        public static final int VRInitError_Driver_HmdDisplayNotFound = 208;
        public static final int VRInitError_Driver_TrackedDeviceInterfaceUnknown = 209;
        public static final int VRInitError_Driver_HmdDriverIdOutOfBounds = 211;
        public static final int VRInitError_Driver_HmdDisplayMirrored = 212;

        public static final int VRInitError_IPC_ServerInitFailed = 300;
        public static final int VRInitError_IPC_ConnectFailed = 301;
        public static final int VRInitError_IPC_SharedStateInitFailed = 302;
        public static final int VRInitError_IPC_CompositorInitFailed = 303;
        public static final int VRInitError_IPC_MutexInitFailed = 304;
        public static final int VRInitError_IPC_Failed = 305;
        public static final int VRInitError_IPC_CompositorConnectFailed = 306;
        public static final int VRInitError_IPC_CompositorInvalidConnectResponse = 307;
        public static final int VRInitError_IPC_ConnectFailedAfterMultipleAttempts = 308;

        public static final int VRInitError_Compositor_Failed = 400;
        public static final int VRInitError_Compositor_D3D11HardwareRequired = 401;
        public static final int VRInitError_Compositor_FirmwareRequiresUpdate = 402;
        public static final int VRInitError_Compositor_OverlayInitFailed = 403;
        public static final int VRInitError_Compositor_ScreenshotsInitFailed = 404;

        public static final int VRInitError_VendorSpecific_UnableToConnectToOculusRuntime = 1000;

        public static final int VRInitError_VendorSpecific_HmdFound_CantOpenDevice = 1101;
        public static final int VRInitError_VendorSpecific_HmdFound_UnableToRequestConfigStart = 1102;
        public static final int VRInitError_VendorSpecific_HmdFound_NoStoredConfig = 1103;
        public static final int VRInitError_VendorSpecific_HmdFound_ConfigTooBig = 1104;
        public static final int VRInitError_VendorSpecific_HmdFound_ConfigTooSmall = 1105;
        public static final int VRInitError_VendorSpecific_HmdFound_UnableToInitZLib = 1106;
        public static final int VRInitError_VendorSpecific_HmdFound_CantReadFirmwareVersion = 1107;
        public static final int VRInitError_VendorSpecific_HmdFound_UnableToSendUserDataStart = 1108;
        public static final int VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataStart = 1109;
        public static final int VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataNext = 1110;
        public static final int VRInitError_VendorSpecific_HmdFound_UserDataAddressRange = 1111;
        public static final int VRInitError_VendorSpecific_HmdFound_UserDataError = 1112;
        public static final int VRInitError_VendorSpecific_HmdFound_ConfigFailedSanityCheck = 1113;

        public static final int EVRInitError_VRInitError_Steam_SteamInstallationNotFound = 2000;
    };

    public static class EVRScreenshotType {

        public static final int VRScreenshotType_None = 0;
        /**
         * left eye only
         */
        public static final int VRScreenshotType_Mono = 1;
        public static final int VRScreenshotType_Stereo = 2;
        public static final int VRScreenshotType_Cubemap = 3;
        public static final int VRScreenshotType_MonoPanorama = 4;
        public static final int VRScreenshotType_StereoPanorama = 5;
    }

    public static class EVRScreenshotPropertyFilenames {

        public static final int VRScreenshotPropertyFilenames_Preview = 0;
        public static final int VRScreenshotPropertyFilenames_VR = 1;
    }

    public static class EVRTrackedCameraError {

        public static final int VRTrackedCameraError_None = 0;
        public static final int VRTrackedCameraError_OperationFailed = 100;
        public static final int VRTrackedCameraError_InvalidHandle = 101;
        public static final int VRTrackedCameraError_InvalidFrameHeaderVersion = 102;
        public static final int VRTrackedCameraError_OutOfHandles = 103;
        public static final int VRTrackedCameraError_IPCFailure = 104;
        public static final int VRTrackedCameraError_NotSupportedForThisDevice = 105;
        public static final int VRTrackedCameraError_SharedMemoryFailure = 106;
        public static final int VRTrackedCameraError_FrameBufferingFailure = 107;
        public static final int VRTrackedCameraError_StreamSetupFailure = 108;
        public static final int VRTrackedCameraError_InvalidGLTextureId = 109;
        public static final int VRTrackedCameraError_InvalidSharedTextureHandle = 110;
        public static final int VRTrackedCameraError_FailedToGetGLTextureId = 111;
        public static final int VRTrackedCameraError_SharedTextureFailure = 112;
        public static final int VRTrackedCameraError_NoFrameAvailable = 113;
        public static final int VRTrackedCameraError_InvalidArgument = 114;
        public static final int VRTrackedCameraError_InvalidFrameBufferSize = 115;

    }

    public static class EVRTrackedCameraFrameType {

        /**
         * This is the camera video frame size in pixels, still distorted.
         */
        public static final int VRTrackedCameraFrameType_Distorted = 0;
        /**
         * In pixels, an undistorted inscribed rectangle region without invalid
         * regions. This size is subject to changes shortly.
         */
        public static final int VRTrackedCameraFrameType_Undistorted = 1;
        /**
         * In pixels, maximum undistorted with invalid regions. Non zero alpha
         * component identifies valid regions.
         */
        public static final int VRTrackedCameraFrameType_MaximumUndistorted = 2;
        public static final int MAX_CAMERA_FRAME_TYPES = 3;
    }

    /**
     * Used for all errors reported by the IVRApplications class
     */
    public static class EVRApplicationError {

        public static final int VRApplicationError_None = 0;

        // Only one application can use any given key
        public static final int VRApplicationError_AppKeyAlreadyExists = 100;
        // the running application does not have a manifest
        public static final int VRApplicationError_NoManifest = 101;
        // No application is running
        public static final int VRApplicationError_NoApplication = 102;
        public static final int VRApplicationError_InvalidIndex = 103;
        // the application could not be found
        public static final int VRApplicationError_UnknownApplication = 104;
        // An IPC failure caused the request to fail
        public static final int VRApplicationError_IPCFailed = 105;
        public static final int VRApplicationError_ApplicationAlreadyRunning = 106;
        public static final int VRApplicationError_InvalidManifest = 107;
        public static final int VRApplicationError_InvalidApplication = 108;
        // the process didn't start
        public static final int VRApplicationError_LaunchFailed = 109;
        // the system was already starting the same application
        public static final int VRApplicationError_ApplicationAlreadyStarting = 110;
        // The system was already starting a different application
        public static final int VRApplicationError_LaunchInProgress = 111;
        public static final int VRApplicationError_OldApplicationQuitting = 112;
        public static final int VRApplicationError_TransitionAborted = 113;
        // error when you try to call LaunchApplication() on a template type app (use LaunchTemplateApplication)
        public static final int VRApplicationError_IsTemplate = 114;

        // The provided buffer was too small to fit the requested data
        public static final int EVRApplicationError_VRApplicationError_BufferTooSmall = 200;
        // The requested property was not set
        public static final int EVRApplicationError_VRApplicationError_PropertyNotSet = 201;
        public static final int EVRApplicationError_VRApplicationError_UnknownProperty = 202;
        public static final int VRApplicationError_InvalidParameter = 203;
    };

    /**
     * these are the properties available on applications.
     */
    public static class EVRApplicationProperty {

        public static final int VRApplicationProperty_Name_String = 0;

        public static final int VRApplicationProperty_LaunchType_String = 11;
        public static final int VRApplicationProperty_WorkingDirectory_String = 12;
        public static final int VRApplicationProperty_BinaryPath_String = 13;
        public static final int VRApplicationProperty_Arguments_String = 14;
        public static final int VRApplicationProperty_URL_String = 15;

        public static final int VRApplicationProperty_Description_String = 50;
        public static final int VRApplicationProperty_NewsURL_String = 51;
        public static final int VRApplicationProperty_ImagePath_String = 52;
        public static final int VRApplicationProperty_Source_String = 53;

        public static final int VRApplicationProperty_IsDashboardOverlay_Bool = 60;
        public static final int VRApplicationProperty_IsTemplate_Bool = 61;
        public static final int VRApplicationProperty_IsInstanced_Bool = 62;

        public static final int VRApplicationProperty_LastLaunchTime_Uint64 = 70;
    };

    /**
     * These are states the scene application startup process will go through.
     */
    public static class EVRApplicationTransitionState {

        public static final int VRApplicationTransition_None = 0;

        public static final int VRApplicationTransition_OldAppQuitSent = 10;
        public static final int VRApplicationTransition_WaitingForExternalLaunch = 11;

        public static final int VRApplicationTransition_NewAppLaunched = 20;
    };

    public static class ChaperoneCalibrationState {

        // OK!
        public static final int ChaperoneCalibrationState_OK = 1;   // Chaperone is fully calibrated and working correctly

        // Warnings
        public static final int ChaperoneCalibrationState_Warning = 100;
        // A base station thinks that it might have moved
        public static final int ChaperoneCalibrationState_Warning_BaseStationMayHaveMoved = 101;
        // There are less base stations than when calibrated
        public static final int ChaperoneCalibrationState_Warning_BaseStationRemoved = 102;
        // Seated bounds haven't been calibrated for the current tracking center
        public static final int ChaperoneCalibrationState_Warning_SeatedBoundsInvalid = 103;

        // Errors
        public static final int ChaperoneCalibrationState_Error = 200;  // The UniverseID is invalid
        // Tracking center hasn't be calibrated for at least one of the base stations
        public static final int ChaperoneCalibrationState_Error_BaseStationUninitalized = 201;
        // Tracking center is calibrated, but base stations disagree on the tracking space
        public static final int ChaperoneCalibrationState_Error_BaseStationConflict = 202;
        // Play Area hasn't been calibrated for the current tracking center
        public static final int ChaperoneCalibrationState_Error_PlayAreaInvalid = 203;
        // Collision Bounds haven't been calibrated for the current tracking center
        public static final int ChaperoneCalibrationState_Error_CollisionBoundsInvalid = 204;
    };

    public static class EChaperoneConfigFile {

        // The live chaperone config, used by most applications and games
        public static final int EChaperoneConfigFile_Live = 1;
        // The temporary chaperone config, used to live-preview collision bounds in room setup
        public static final int EChaperoneConfigFile_Temp = 2;
    };

    public static class EChaperoneImportFlags {

        public static final int EChaperoneImport_BoundsOnly = 1;
    };

    /**
     * Errors that can occur with the VR compositor
     */
    public static class EVRCompositorError {

        public static final int VRCompositorError_None = 0;
        public static final int VRCompositorError_RequestFailed = 1;
        public static final int VRCompositorError_IncompatibleVersion = 100;
        public static final int VRCompositorError_DoNotHaveFocus = 101;
        public static final int VRCompositorError_InvalidTexture = 102;
        public static final int VRCompositorError_IsNotSceneApplication = 103;
        public static final int VRCompositorError_TextureIsOnWrongDevice = 104;
        public static final int VRCompositorError_TextureUsesUnsupportedFormat = 105;
        public static final int VRCompositorError_SharedTexturesNotSupported = 106;
        public static final int VRCompositorError_IndexOutOfRange = 107;
    };

    /**
     * Types of input supported by VR Overlays
     */
    public static class VROverlayInputMethod {

        // No input events will be generated automatically for this overlay
        public static final int VROverlayInputMethod_None = 0;
        // Tracked controllers will get mouse events automatically
        public static final int VROverlayInputMethod_Mouse = 1;
    };

    /**
     * Allows the caller to figure out which overlay transform getter to call.
     */
    public static class VROverlayTransformType {

        public static final int VROverlayTransform_Absolute = 0;
        public static final int VROverlayTransform_TrackedDeviceRelative = 1;
        public static final int VROverlayTransform_SystemOverlay = 2;
        public static final int VROverlayTransform_TrackedComponent = 3;
    };

    /**
     * Overlay control settings
     */
    public static class VROverlayFlags {

        public static final int None = 0;

        // The following only take effect when rendered using the high quality render path (see SetHighQualityOverlay).
        public static final int Curved = 1;
        public static final int RGSS4X = 2;

        // Set this flag on a dashboard overlay to prevent a tab from showing up for that overlay
        public static final int NoDashboardTab = 3;

        // Set this flag on a dashboard that is able to deal with gamepad focus events
        public static final int AcceptsGamepadEvents = 4;

        // Indicates that the overlay should dim/brighten to show gamepad focus
        public static final int ShowGamepadFocus = 5;

        // When in VROverlayInputMethod_Mouse you can optionally enable sending VRScroll_t 
        public static final int SendVRScrollEvents = 6;
        public static final int SendVRTouchpadEvents = 7;
        /**
         * If set this will render a vertical scroll wheel on the primary
         * controller, only needed if not using
         * VROverlayFlags_SendVRScrollEvents but you still want to represent a
         * scroll wheel.
         */
        public static final int ShowTouchPadScrollWheel = 8;
        /**
         * If this is set ownership and render access to the overlay are
         * transferred to the new scene process on a call to
         * IVRApplications::LaunchInternalProcess.
         */
        public static final int TransferOwnershipToInternalProcess = 9;
        /**
         * If set, renders 50% of the texture in each eye, side by side <br>
         * Texture is left/right
         */
        public static final int SideBySide_Parallel = 10;
        /**
         * If set, renders 50% of the texture in each eye, side by side <br>
         * Texture is crossed and right/left
         */
        public static final int SideBySide_Crossed = 11;
        /**
         * Texture is a panorama
         */
        public static final int Panorama = 12;
        /**
         * Texture is a stereo panorama
         */
        public static final int StereoPanorama = 13;
        /**
         * If this is set on an overlay owned by the scene application that
         * overlay will be sorted with the "Other" overlays on top of all other
         * scene overlays
         */
        public static final int SortWithNonSceneOverlays = 14;
    };

    // Input modes for the Big Picture gamepad text entry
    public static class EGamepadTextInputMode {

        public static final int k_EGamepadTextInputModeNormal = 0;
        public static final int k_EGamepadTextInputModePassword = 1;
        public static final int k_EGamepadTextInputModeSubmit = 2;
    };

    // Controls number of allowed lines for the Big Picture gamepad text entry
    public static class EGamepadTextInputLineMode {

        public static final int k_EGamepadTextInputLineModeSingleLine = 0;
        public static final int k_EGamepadTextInputLineModeMultipleLines = 1;
    };

    /**
     * Directions for changing focus between overlays with the gamepad
     */
    public static class EOverlayDirection {

        public static final int OverlayDirection_Up = 0;
        public static final int OverlayDirection_Down = 1;
        public static final int OverlayDirection_Left = 2;
        public static final int OverlayDirection_Right = 3;

        public static final int OverlayDirection_Count = 4;
    };

    /**
     * Errors that can occur with the VR compositor
     */
    public static class EVRRenderModelError {

        public static final int VRRenderModelError_None = 0;
        public static final int VRRenderModelError_Loading = 100;
        public static final int VRRenderModelError_NotSupported = 200;
        public static final int VRRenderModelError_InvalidArg = 300;
        public static final int VRRenderModelError_InvalidModel = 301;
        public static final int VRRenderModelError_NoShapes = 302;
        public static final int VRRenderModelError_MultipleShapes = 303;
        public static final int VRRenderModelError_TooManyVertices = 304;
        public static final int VRRenderModelError_MultipleTextures = 305;
        public static final int VRRenderModelError_BufferTooSmall = 306;
        public static final int VRRenderModelError_NotEnoughNormals = 307;
        public static final int VRRenderModelError_NotEnoughTexCoords = 308;
        public static final int VRRenderModelError_InvalidTexture = 400;
    };

    public static class EVRComponentProperty {

        public static final int VRComponentProperty_IsStatic = (1);
        public static final int VRComponentProperty_IsVisible = (2);
        public static final int VRComponentProperty_IsTouched = (4);
        public static final int VRComponentProperty_IsPressed = (8);
        public static final int VRComponentProperty_IsScrolled = (16);
    };

    public static class EVRNotificationType {

        /**
         * Transient notifications are automatically hidden after a period of
         * time set by the user. They are used for things like information and
         * chat messages that do not require user interaction.
         */
        public static final int Transient = 0;
        /**
         * Persistent notifications are shown to the user until they are hidden
         * by calling RemoveNotification(). They are used for things like phone
         * calls and alarms that require user interaction.
         */
        public static final int Persistent = 1;
        /**
         * System notifications are shown no matter what. It is expected, that
         * the ulUserValue is used as ID. If there is already a system
         * notification in the queue with that ID it is not accepted into the
         * queue to prevent spamming with system notification
         */
        public static final int Transient_SystemWithUserValue = 2;
    };

    public static class EVRNotificationStyle {

        /**
         * Creates a notification with minimal external styling.
         */
        public static final int EVRNotificationStyle_None = 0;
        /**
         * Used for notifications about overlay-level status. In Steam this is
         * used for events like downloads completing.
         */
        public static final int EVRNotificationStyle_Application = 100;
        /**
         * Used for notifications about contacts that are unknown or not
         * available. In Steam this is used for friend invitations and offline
         * friends.
         */
        public static final int EVRNotificationStyle_Contact_Disabled = 200;
        /**
         * Used for notifications about contacts that are available but
         * inactive. In Steam this is used for friends that are online but not
         * playing a game.
         */
        public static final int EVRNotificationStyle_Contact_Enabled = 201;
        /**
         * Used for notifications about contacts that are available and active.
         * In Steam this is used for friends that are online and currently
         * running a game.
         */
        public static final int EVRNotificationStyle_Contact_Active = 202;
    };

    public static class EVRSettingsError {

        public static final int VRSettingsError_None = 0;
        public static final int VRSettingsError_IPCFailed = 1;
        public static final int VRSettingsError_WriteFailed = 2;
        public static final int VRSettingsError_ReadFailed = 3;
    };

    public static class EVRScreenshotError {

        public static final int VRScreenshotError_None = 0;
        public static final int VVRScreenshotError_RequestFailed = 1;
        public static final int VRScreenshotError_IncompatibleVersion = 100;
        public static final int VRScreenshotError_NotFound = 101;
        public static final int VRScreenshotError_BufferTooSmall = 102;
        public static final int VRScreenshotError_ScreenshotAlreadyInProgress = 108;
    }

    /**
     * Global entry points<br>
     * Original signature :
     * <code>intptr_t VR_InitInternal(EVRInitError*, EVRApplicationType)</code>
     *
     * @param peError
     * @param eType
     * @return
     */
    public static native Pointer VR_InitInternal(IntBuffer peError, int eType);

    /**
     * Original signature : <code>void VR_ShutdownInternal()</code>
     */
    public static native void VR_ShutdownInternal();

    /**
     * Original signature : <code>bool VR_IsHmdPresent()</code>
     *
     * Returns true if there is an HMD attached. This check is as lightweight as
     * possible and can be called outside of VR_Init/VR_Shutdown. It should be
     * used when an application wants to know if initializing VR is a
     * possibility but isn't ready to take that step yet.
     *
     * @return
     */
    public static native byte VR_IsHmdPresent();

    /**
     * Original signature :
     * <code>intptr_t VR_GetGenericInterface(const char*, EVRInitError*)</code>
     *
     * Returns the class of the specified version. This method must be called
     * after VR_Init. The pointer returned is valid until VR_Shutdown is called.
     *
     * @param pchInterfaceVersion
     * @param peError
     * @return
     */
    public static native Pointer VR_GetGenericInterface(String pchInterfaceVersion, IntBuffer peError);

    /**
     * Original signature : <code>bool VR_IsRuntimeInstalled()</code>
     *
     * Returns true if the OpenVR runtime is installed.
     *
     * @return
     */
    public static native byte VR_IsRuntimeInstalled();

    /**
     * Original signature :
     * <code>char* VR_GetVRInitErrorAsSymbol(EVRInitError)</code>
     *
     * Returns the name of the enum value for an EVRInitError. This function may
     * be called outside of VR_Init()/VR_Shutdown().
     *
     * @param error
     * @return
     */
    public static native Pointer VR_GetVRInitErrorAsSymbol(int error);

    /**
     * Original signature :
     * <code>char* VR_GetVRInitErrorAsEnglishDescription(EVRInitError)</code>
     *
     * Returns an english string for an EVRInitError. Applications should call
     * VR_GetVRInitErrorAsSymbol instead and use that as a key to look up their
     * own localized error message. This function may be called outside of
     * VR_Init()/VR_Shutdown().
     *
     * @param error
     * @return
     */
    public static native Pointer VR_GetVRInitErrorAsEnglishDescription(int error);

    /**
     * Original signature :
     * <code>VR_INTERFACE void *VR_CALLTYPE VR_GetGenericInterface( const char *pchInterfaceVersion, EVRInitError *peError )</code>
     *
     * Returns the interface of the specified version. This method must be
     * called after VR_Init. The pointer returned is valid until VR_Shutdown is
     * called.
     *
     * @param pchInterfaceVersion
     * @param peError
     * @return
     */
    public static native Pointer VR_GetGenericInterface(String pchInterfaceVersion, int peError);

    /**
     * Original signature :
     * <code>VR_INTERFACE bool VR_CALLTYPE VR_IsInterfaceVersionValid( const char *pchInterfaceVersion )</code>
     *
     * Returns whether the interface of the specified version exists.
     *
     * @param pchInterfaceVersion
     * @return
     */
    public static native byte VR_IsInterfaceVersionValid(String pchInterfaceVersion);

    /**
     * Original signature :
     * <code>VR_INTERFACE uint32_t VR_CALLTYPE VR_GetInitToken()</code>
     *
     * Returns a token that represents whether the VR interface handles need to
     * be reloaded
     *
     * @return
     */
    public static native int VR_GetInitToken();

    /**
     * Finds the active installation of vrclient.dll and initializes it.
     *
     * @param error
     * @param applicationType
     * @return
     */
    public static IVRSystem VR_Init(IntBuffer error, int applicationType) {

        IVRSystem vrSystem = null;

        VR_InitInternal(error, applicationType);
        COpenVRContext ctx = new COpenVRContext();
        ctx.clear();

        if (error.get(0) == EVRInitError.VRInitError_None) {

            if (VR_IsInterfaceVersionValid(IVRSystem_Version) != 0) {

                vrSystem = new IVRSystem(VR_GetGenericInterface(IVRSystem_Version, error));

            } else {

                VR_ShutdownInternal();
                error.put(0, EVRInitError.VRInitError_Init_InterfaceNotFound);
            }
        }
        return vrSystem;
    }

    /**
     * Unloads vrclient.dll. Any interface pointers from the interface are invalid after this point.
     */
    public static void VR_Shutdown() {
        VR_ShutdownInternal();
    }
}
